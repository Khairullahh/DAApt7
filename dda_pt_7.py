# -*- coding: utf-8 -*-
"""DDA pt 7.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/12t3F5RsTvlDXPonL4OS2AoZDlX5olPJQ

Algoritma Brute Force : Sequental Search
"""

def Sequential_Search(dilist, item):

    pos = 0
    found = False

    while pos < len(dilist) and not found:
        if dilist[pos] == item:
             found = True
        else:
            pos = pos + 1

    return found, pos

print(Sequential_Search([11,23,58,31,56,77,43,12,65,19],12))

"""latihan mencari string g"""

def Sequential_Search(dilist, item):

    pos = 0
    found = False

    while pos < len(dilist) and not found:
        if dilist[pos] == item:
             found = True
        else:
            pos = pos + 1

    return found, pos

print(Sequential_Search(['a','b','c','d','e','f','g','h'],'g'))

"""algoritma brute force: pangkat"""

bilangan = int(input('masukkan bilangan: '))
pangkat = int(input('masukkan pangkat: '))

def hitung_pangkat(bilangan, pangkat):
  if pangkat > 1:
    return bilangan * hitung_pangkat(bilangan, pangkat - 1)

  elif pangkat == 0 :
      return bilangan/bilangan

  return bilangan

hasil = hitung_pangkat(bilangan, pangkat)
print(f'hasil = {hasil}')

"""algoritma brute force: faktorial,contoh 5 = 5x4x3x2x1 = 120"""

n = int(input('masukkan nilai n: '))

def hitung_faktorial (n) :
  if n >2:
    return n * hitung_faktorial(n - 1)

  return 2

faktorial = hitung_faktorial(n)
print(f'{n} = {faktorial}')

"""algoritma brute force: string matching"""

def string_match(string, sub_str):
  # brute force string matching
  for i in range(len(string)-len(sub_str)+1):
   index = i # index point to the 1 sampai three character to be compared
   for j in range(len(sub_str)):
     if string[index] == sub_str[j]:
      index += 1
     else:
      break
     if index-i == len(sub_str):
      return i
  return -1  

if __name__ == "__main__":
 print(string_match("adbcbdc","bdc"))

"""latihan"""

def string_match(string, sub_str):
  # brute force string matching
  for i in range(len(string)-len(sub_str)+1):
   index = i # index point to the 1 sampai three character to be compared
   for j in range(len(sub_str)):
     if string[index] == sub_str[j]:
      index += 1
     else:
      break
     if index-i == len(sub_str):
      return i
  return -1  

if __name__ == "__main__":
 print(string_match("123456789","56"))

"""algoritma brute force penerapan algoritma greedy pada tsp(travelling salesman/salesperson problem) dan grafiknya"""

import random
from itertools import permutations
alltours = permutations

def distance_tour(aTour):
    return sum(distance_points(aTour[i - 1], aTour[i])
        for i in range(len(aTour)))
    
aCity = complex    

def distance_points(first, second):
    return abs(first - second)

def generate_cities (number_of_cities):
    seed=111;width=500;height=300
    random.seed((number_of_cities, seed))
    return frozenset(aCity(random.randint(1, width), random.randint(1,height))
        for c in range(number_of_cities))

"""slide ke 2"""

# Commented out IPython magic to ensure Python compatibility.
# %matplotlib inline
import matplotlib.pyplot as plt

def visualize_tour(tour, style='bo-'):
    if len(tour) > 1000: plt.figure(figsize=(15, 10))
    start = tour[0:1]
    visualize_segment(tour + start, style)
    visualize_segment(start, 'rD') 
def visualize_segment (segment, style='bo-'):
        plt.plot([X(c) for c in segment], [Y(c) for c in segment], style, clip_on=False)
        plt.axis('scaled')
        plt.axis('off')
def X(city): "X axis"; return city.real

def Y(city): "Y axis"; return city.imag

"""slide ke 3"""

from time import process_time
from collections import Counter
def tsp(algorithm, cities):
    t0 = process_time()
    tour = algorithm(cities)
    t1 = process_time()
    assert Counter(tour) == Counter(cities)
    visualize_tour(tour)
    print("{}:{} cities => tour length {:.0f}(in {:.3f} sec)".format(name(algorithm), len(tour), distance_tour(tour), t1-t0))



def name(algorithm): return algorithm.__name__.replace('_tsp','')

"""slide ke 4"""

def brute_force(cities):
   "generate all possible tours of the cities and choose the shoortest tour."
   return shortest_tour(alltours(cities))
def shortest_tour(tours): return min(tours, key=distance_tour)

tsp(brute_force, generate_cities(10))